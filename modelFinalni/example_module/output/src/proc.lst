1     	 0000				_PROC_ASM
2     						
3     							.if defined (_PROC_ASM)
4     						.include "example_module_mcv.h"
4      >> open include file: D:/fax/aadspproj/aadspProj/modelFinalni/example_module/gen/inc/example_module_mcv.h
1+    						/*
2+    						 * This file is automatically generated by CLIDE
3+    						 *
4+    						 * MCV (Module Control Vector)
5+    						 */
6+    						.include "dsplib/meter_asm.h" 
6+     >> open include file: C:/CirrusDSP/include/dsplib/meter_asm.h
1+    							.if !defined(_meter_h_)
2+    	 0000				_meter_h_
3+    						
4+    						METER_T .struct
5+    						RMS .dw 0			#fract(1.31)
6+    						RMS_HOLD .dw 0		#fract(1.31)
7+    						PEAK .dw 0			#fract(1.31)
8+    						PEAK_HOLD .dw 0		#fract(1.31)
9+    							.endstruct
10+   						
11+   						(null)11+    >> end of include file: C:/CirrusDSP/include/dsplib/meter_asm.h
11+    >> continuing with file: D:/fax/aadspproj/aadspProj/modelFinalni/example_module/gen/inc/example_module_mcv.h
7+    						.include "dsplib/response_asm.h"
7+     >> open include file: C:/CirrusDSP/include/dsplib/response_asm.h
1+    							.if !defined(_response_h_)
2+    	 0000				_response_h_
3+    						
4+    						BIQUAD_T .struct
5+    						COEF_A1 .dw 0			#fract(2.30)
6+    						COEF_A2 .dw 0			#fract(2.30)
7+    						COEF_B0 .dw 1			#fract(3.29)
8+    						COEF_B1 .dw 0			#fract(3.29)
9+    						COEF_B2 .dw 0			#fract(3.29)
10+   							.endstruct
11+   						
12+   						RESPONSE_T .struct
13+   						PRE .dw 0			#fract(7.25)
14+   						POST .dw 0			#fract(7.25)
15+   							.rept %i = 0,2
16+   						BIQUAD_%i BIQUAD_T		#struct
17+    >> start of macro: .rept
1+    						BIQUAD_0 BIQUAD_T		#struct
2+    						BIQUAD_1 BIQUAD_T		#struct
3+    						BIQUAD_2 BIQUAD_T		#struct
4+    						
17+   							.endm
18+   							.endstruct
19+   							
20+   							.endif21+   						(null)21+    >> end of include file: C:/CirrusDSP/include/dsplib/response_asm.h
21+    >> continuing with file: D:/fax/aadspproj/aadspProj/modelFinalni/example_module/gen/inc/example_module_mcv.h
8+    						
9+    	 0001				isDefined	 .equ 	 1
10+   						
11+   						MCV_T	.struct
12+   						mode1 .dw 0	 #bool
13+   						enable .dw 0	 # bool	non-zero to enable this function
14+   						inputGain .dw 0	 #fract(1.31)
15+   							.endstruct
16+   						
17+   						
18+   	 0000				STRUCTURE_INITIALIZATION_STRNG .equ "0x0, 0x1, 0x00000000"
19+    >> end of include file: D:/fax/aadspproj/aadspProj/modelFinalni/example_module/gen/inc/example_module_mcv.h
19+    >> continuing with file: D:/fax/aadspproj/aadspProj/modelFinalni/example_module/src/proc.a
5     						
6     						
7     	 0000				_L_CH .equ 0
8     	 0001				_R_CH .equ 1
9     	 0002				_LS_CH .equ 2
10    	 0003				_RS_CH .equ 3
11    	 0004				_C_CH .equ 4
12    	 0010				_BLOCK_SIZE .equ 16
13    	 0017				_FILTER_LENGHT .equ 23
14    						
15    	 0000					.public _processing
16    	 0000					.extern _inputGain
17    	 0000					.extern _limiterThreshold
18    	 0000					.extern _saturation
19    	 0000					.extern _modeFlag
20    	 0000					.extern _hpfCoefs
21    	 0000					.extern _lpfCoefs
22    	 0000					.extern _lpfHistoryBuffer
23    	 0000					.extern _hpfHistoryBuffer
24    	 0000					.extern example_module_MCV(MCV_T)
25    							
26    						 	.code_ovly 
26     >> start of macro: .code_ovly
1+    									seg_single , "CODE_OVLY", CODE
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_CODE_ )
2+    						    segment
3+    						  .else
4+    						    segment "CODE_OVLY"
5+    							.if "" != ""
6+    						___SegStart_CODE_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .code_ovly
27    						 	
28    						 	# prema CCC2 pozivnoj konvenciji: 
29    						 	# i0 - parametar pokazivac, pIn
30    						 	# i1 - parametar pokazivac, pOut
31    	 0000				_processing:
32    						
33    							# Save index registers on stack
34    	 0000	 B2540017		xmem[i7] = i2; i7 += 1;
35    	 0001	 B3540017		xmem[i7] = i3; i7 += 1;
36    	 0002	 B8540017		xmem[i7] = i4; i7 += 1;
37    	 0003	 B9540017		xmem[i7] = i5; i7 += 1;
38    	 0004	 BA540017		xmem[i7] = i6; i7 += 1;
39    							#save accums to the stack
40    	 0005	 8A540017		xmem[i7] = a2; i7 += 1;
41    	 0006	 8E540017		xmem[i7] = b2; i7 += 1;
42    	 0007	 8B540017		xmem[i7] = a3; i7 += 1;
43    	 0008	 8F540017		xmem[i7] = b3; i7 += 1;
44    						
45    						//    input pointers
46    						#	__memY DSPfract* L_CH_In_Ptr = *pIn; //already in i0
47    						# 	__memY DSPfract* R_CH_In_Ptr = *(pIn + R_CH);
48    	 0009	 82050010		i2 = i0 + (_R_CH * _BLOCK_SIZE)   
49    						// output pointers
50    						#	__memY DSPfract* L_CH_Out_Ptr = *pOut; already in i1
51    						#	__memY DSPfract* R_CH_Out_Ptr = *(pOut + R_CH);
52    	 000A	 83150010		i3 = i1 + (_R_CH * _BLOCK_SIZE)	
53    						#	__memY DSPfract* RS_CH_Out_Ptr = *(pOut + RS_CH);
54    	 000B	 84150020		i4 = i1 + (_LS_CH * _BLOCK_SIZE)
55    						#	__memY DSPfract* LS_CH_Out_Ptr = *(pOut + LS_CH);
56    	 000C	 85150030		i5 = i1 + (_RS_CH * _BLOCK_SIZE)
57    						# 	__memY DSPfract* C_CH_Out_Ptr = *(pOut + C_CH);
58    	 000D	 86150040		i6 = i1 + (_C_CH * _BLOCK_SIZE)
59    						
60    						
61    						#index register mapping:
62    						# i0=L_CH_In_Ptr
63    						# i2=R_CH_In_Ptr
64    						# i1=L_CH_Out_Ptr
65    						# i3=R_CH_Out_Ptr
66    						# i4=LS_CH_Out_Ptr 
67    						# i5=RS_CH_Out_Ptr
68    						# i6=C_CH_Out_Ptr
69    						#i7	STACK BOUND
70    						#
71    						
72    						#	DSPaccum processed_L_CH=0.0;a2 // these will be replaced by registers a2 & b2
73    						#	DSPaccum processed_R_CH=0.0;b2
74    						#	DSPaccum centerSum=0.0;
75    						#  DSPint j;  //will be replaced with a hw loop  along with the for
76    						
77    						#	for ( j = 0; j < BLOCK_SIZE; j++)
78    							#{
79    						##################################################################
80    						//processing loop
81    						#################################################################
82    								
83    	 000E	 81000039		do(_BLOCK_SIZE),>loop
84    								#######################################################
85    								//first stage, apply inputGain on L & R channels 
86    								######################################################
87    								
88    								//L_CH
89    								# processed_L_CH = (DSPfract)(*L_CH_In_Ptr) * (DSPfract)(inputGain);
90    								# *L_CH_Out_Ptr = (DSPfract)saturation(processed_L_CH);
91    								#L_CH_In_Ptr++;
92    	 000F	 84940010			y0 = ymem[i0]; i0 += 1  // loads the sample value and moves input  pointer through the block
93    	 0010	 80040000			x0 = xmem[example_module_MCV.inputGain]   //loads inputGain
94    	 0011	 00002400			a0 = x0 * y0 //applies gain output of L_Ch of this phase is in a0
95    	 0012	 8C040000			b0 = xmem[_limiterThreshold]
96    							# if (in < limiterThreshold)
97    							#	a0 - b0
98    							#	if (a < 0) jmp>less
99    							#		a0 = b0
100   							#		jmp>endSaturation
101   						#%less: 
102   						#	 if (in >= -limiterThreshold)
103   						#		b0 = -b0
104   						#		a0 - b0
105   						#		if (a >= 0) jmp>endSaturation
106   						#			a0 = b0	
107   						#%endSaturation:
108   							//optimised saturation
109   	 0013	 00004860			if(b0<a0) a0=b0
110   	 0014	 00004C84				b0=-b0
111   	 0015	 00004820			if(b0>a0) a0=b0
112   						
113   								//L_CH
114   								# *LS_CH_Out_Ptr = (DSPfract)processed_L_CH;
115   	 0016	 88D40014			ymem[i4]=a0; i4+=1//writes corrected volumes of L_CH To LS_CH
116   								
117   								
118   								//R_CH
119   								#pIn[R_CH][j] = saturation(pIn[R_CH][j] * variablesGain[R_CH]);
120   								# processed_R_CH = (DSPfract)(*R_CH_In_Ptr) * (DSPfract)(inputGain);
121   								# *R_CH_Out_Ptr = (DSPfract)saturation(processed_R_CH);
122   								#R_CH_In_Ptr++;
123   	 0017	 85940012			y1 = ymem[i2]; i2 += 1  // loads the sample value and moves input pointer through the block
124   								//inputGain same for both
125   	 0018	 00002421			a1 = y1 * x0 //applies gain output of R_Ch of this phase is in a1
126   	 0019	 8D040000			b1 = xmem[_limiterThreshold]
127   								# if (in < limiterThreshold)
128   							#	a1 - b1
129   							#	if (a < 0) jmp>less
130   							#		a1 = b1
131   							#		jmp>endSaturation
132   						#%less: 
133   						#	# if (in >= -limiterThreshold)
134   						#		b1 = -b1
135   						#		a1 - b1
136   						#		if (a >= 0) jmp>endSaturation
137   						#			a1 = b1	
138   						#%endSaturation:
139   	 001A	 00004869			if(b1<a1) a1=b1
140   	 001B	 00004C8D				b1=-b1
141   	 001C	 00004829			if(b1>a1) a1=b1
142   								
143   								
144   								
145   								##################################################################
146   								//passing through processed L & R channels To Ls and Rs channels
147   								##################################################################
148   								
149   							
150   								//R_CH
151   								# *RS_CH_Out_Ptr = (DSPfract)processed_R_CH;
152   	 001D	 89D40015			ymem[i5]=a1;i5+=1//writes corrected volumes of R_CH To RS_CH	
153   								
154   							
155   							
156   							
157   								########################################################
158   								//mode 0 1 dependent processing
159   								########################################################
160   								
161   								#processed_L_CH = (DSPfract)*L_CH_Out_Ptr;
162   	 001E	 484B7FFF			a3=a0 //saving a0 for further use
163   								#processed_R_CH = (DSPfract)*R_CH_Out_Ptr; 
164   	 001F	 494F7FFF			b3=a1 //saving a0 for further use
165   								
166   								
167   								
168   								// fir filtering part
169   								# if (modeFlag)  //mode check logic
170   	 0020	 00004D56			b2=b2^b2 //puts  0 into b2
171   	 0021	 8A040000			a2=xmem[example_module_MCV.mode1]
172   								
173   	 0022	 00004F36			b2-a2
174   	 0023	 86080032			if(b==0) jmp>mode0
175   								
176   								//mode 1 processing
177   								#	{	//doing fir filtering on L&R channels
178   						///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
179   								//L_CH
180   	 0024	 B8540017			xmem[i7] = i4; i7 += 1; //saving i0 and i1 registers with pointers to the L_Ch_in and L_Ch_out so they can be used for a function call
181   	 0025	 B1540017			xmem[i7] = i1; i7 += 1; 
182   								//prepping arguments for L_CH
183   								//correct value is already in a0
184   	 0026	 B84A0000			i4=(_hpfCoefs)
185   	 0027	 B14A0000			i1=(_hpfHistoryBuffer)
186   								// we are calling this function fir_basic( DSPfract input(in a0), __memY DSPfract* coeffs(in i0),  __memX DSPfract* history(in i1))
187   								//this call 
188   								#  	*L_CH_Out_Ptr = fir_basic(*L_CH_Out_Ptr,hpfCoefs, hpfHistoryBuffer);
189   	 0028	 80880045			call _fir_basic
190   								
191   								
192   								
193   								#processed_L_CH = (DSPfract)*L_CH_Out_Ptr;
194   	 0029	 484B7FFF			a3=a0;//saving result of this phase for next phase   a2
195   								//prepping arguments for R_CH
196   								
197   						//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
198   								
199   								
200   								//R_CH
201   	 002A	 49487FFF			a0=a1
202   								 //putting the R_Ch value into a0
203   	 002B	 B84A0000			i4=(_lpfCoefs)
204   	 002C	 B14A0000			i1=(_lpfHistoryBuffer)
205   								//this call
206   								#  	*R_CH_Out_Ptr = fir_basic(*R_CH_Out_Ptr,lpfCoefs, lpfHistoryBuffer);
207   	 002D	 80880045			call _fir_basic
208   								
209   								#processed_R_CH = (DSPfract)*R_CH_Out_Ptr; 
210   	 002E	 484F7FFF			b3=a0 ////saving result of this phase for next phase
211   								
212   								
213   								//restoring values from the stack
214   	 002F	 02177FFF			i7 -= 1;
215   								
216   	 0030	 B1140027			i1=xmem[i7]; i7 -= 1;
217   	 0031	 B8140007			i4=xmem[i7];
218   	 0032				%mode0:
219   								
220   								
221   	 0032	 8BD40011			ymem[i1]=a3;i1+=1
222   								
223   	 0033	 8FD40013			ymem[i3]=b3;i3+=1
224   								
225   								
226   								// generate C_CH as a sum of L & R output channels
227   								#centerSum = (DSPfract)processed_L_CH + (DSPfract)processed_R_CH;
228   								#*C_CH_Out_Ptr = (DSPfract)saturation(centerSum);
229   								//a0 no longer in use so can be used for centerSum variable
230   	 0034	 000045B8			a0=a3+b3
231   								
232   	 0035	 8C040000			b0 = xmem[_limiterThreshold]
233   							# if (in < limiterThreshold)
234   							#	a0 - b0
235   							#	if (a < 0) jmp>less
236   							#		a0 = b0
237   							#		jmp>endSaturation
238   						#%less: 
239   						#	 if (in >= -limiterThreshold)
240   						#		b0 = -b0
241   						#		a0 - b0
242   						#		if (a >= 0) jmp>endSaturation
243   						#			a0 = b0	
244   						#%endSaturation:
245   							//optimised saturation
246   	 0036	 00004860			if(b0<a0) a0=b0
247   	 0037	 00004C84				b0=-b0
248   	 0038	 00004820			if(b0>a0) a0=b0
249   						
250   								//move through a buffer
251   								#L_CH_Out_Ptr++;
252   								#R_CH_Out_Ptr++;
253   								#LS_CH_Out_Ptr++;
254   								#RS_CH_Out_Ptr++;
255   								#C_CH_Out_Ptr++;
256   						
257   						
258   	 0039	 88D40016	%loop: ymem[i6]=a0;i6+=1
259   						
260   	 003A				_end_processing:
261   						//stack restoring
262   	 003A	 02177FFF		i7 -= 1;
263   							
264   							#return accums to prev state
265   	 003B	 8F140027		b3=xmem[i7] ; i7 -= 1;
266   	 003C	 8B140027		a3=xmem[i7] ; i7 -= 1;
267   	 003D	 8E140027		b2=xmem[i7] ; i7 -= 1;
268   	 003E	 8A140027		a2=xmem[i7] ; i7 -= 1;
269   							# return index regs to prev stat
270   	 003F	 BA140027		i6=xmem[i7]; i7 -= 1;
271   	 0040	 B9140027		i5=xmem[i7]; i7 -= 1;
272   	 0041	 B8140027		i4=xmem[i7]; i7 -= 1;
273   	 0042	 B3140027		i3=xmem[i7] ; i7 -= 1;
274   	 0043	 B2140007		i2=xmem[i7] ; 
275   							
276   	 0044	 81880000		ret
277   						############################################################
278   						############################################################
279   						//fir filter 	
280   						############################################################	
281   	 0045				_fir_basic:
282   							//DSPint i;
283   							//DSPfract ret_val = 0;
284   							//input is in a0
285   							#save registers to stack
286   	 0045	 B3540017		xmem[i7] = i3; i7 += 1;
287   							#save accums to the stack
288   	 0046	 8A540007		xmem[i7] = a2;
289   						
290   							
291   							
292   							//pointers to second to last and last array members
293   							#DSPfract* nexthistoryBufferPtr = history + (FILTER_LENGHT-1);
294   	 0047	 83150016		i3 = i1 + ((_FILTER_LENGHT)-1);
295   							#DSPfract* historyBufferPtr = history+(FILTER_LENGHT-2);
296   	 0048	 81150015		i1 = i1+((_FILTER_LENGHT)-2);
297   							
298   						
299   							//shifting all values of the history buffer towards the end by one to make room for a new value	
300   							#for (i = FILTER_LENGHT - 2; i >= 0; i--)
301   							#{
302   	 0049	 8170004B		do(_FILTER_LENGHT),>loop
303   							#*nexthistoryBufferPtr = *historyBufferPtr; //shift by one
304   	 004A	 8A140021		a2=xmem[i1];i1-=1
305   							 // moving pointers towards the beggining
306   							#nexthistoryBufferPtr--;
307   	 004B	 8A540023	%loop:xmem[i3]=a2;i3-=1
308   						
309   							#historyBufferPtr++; //ptr in i1 was pointing 2 places before the beggining setting it to point to beggining of the array
310   	 004C	 02297FFF		i1+=2; 
311   							/* store input at the beginning of the delay line */
312   							#*historyBufferPtr = input; 
313   	 004D	 88540001		xmem[i1]=a0
314   							
315   							//initilising coeff pointer
316   							#DSPfract* coeffsPtr = coeffs; 
317   							//already in a2
318   							
319   							/* calc FIR via convolution*/
320   							#for (i = 0; i < FILTER_LENGHT; i++)
321   							#{
322   							#	multiplyResult = ((*coeffsPtr) * (*historyBufferPtr));
323   							#	ret_val += multiplyResult; //descrete convolution 
324   							#	coeffsPtr++;
325   							#	historyBufferPtr++;
326   							#}
327   	 004E	 00004D40		a0=a0^a0//initialising accum to 0
328   	 004F	 84940014		y0=ymem[i4];i4+=1 //preloading the value 
329   	 0050	 80140011		x0=xmem[i1];i1+=1
330   	 0051	 81700052		do(_FILTER_LENGHT),>loop
331   							//x0=xmem[i1];i1+=1
332   							
333   	 0052	 28882408	%loop:a0+=x0*y0;y0=ymem[i4];i4+=1;x0=xmem[i1];i1+=1// 2 instructions in the loop vs 3
334   							
335   							
336   							#return ret_val;
337   						
338   	 0053				_end_fir_basic:
339   							#return accums to prev state
340   							 #we have to decrement before putting any values because the pointer is currently pointing to 1 adress after value put on stack
341   	 0053	 8A140027		a2=xmem[i7] ; i7 -= 1;
342   							# return index regs to prev stat
343   	 0054	 B3140007		i3=xmem[i7] ; //i7-=1;
344   	 0055	 81880000		ret
345   						
346   						
347   							.endif
348   							
				 SYMBOL TABLE 

    Name                                                                                    Type                  Value 

STRUCTURE_INITIALIZATION_STRNG                                                  			  Unused String		   '0x0, 0x1, 0x00000000' 
_BLOCK_SIZE                                                                     					 Number				          16 (10H)
_COMMON_INC_PATH_                                                               					 Define                 "C:/CirrusDSP/crystal32/common/inc/"
_C_CH                                                                           					 Number				          4 (4H)
_DSP_                                                                           			  Unused Variable		        0 (0H)
_FILTER_LENGHT                                                                  					 Number				          23 (17H)
_LOCAL_INC_PATH_                                                                					 Define                 "inc/"
_LOCAL_SRC_PATH_                                                                					 Define                 "src/"
_LS_CH                                                                          					 Number				          2 (2H)
_L_CH                                                                           			  Unused Number				     0 (0H)
_PROC_ASM                                                                       			  Unused Relocatable        __INIT:0000H
_ROUTER_INC_PATH_                                                               					 Define                 "rom_inc/"
_RS_CH                                                                          					 Number				          3 (3H)
_R_CH                                                                           					 Number				          1 (1H)
__CASM_VER__                                                                    			  Unused Variable		        0 (701H)
_end_fir_basic                                                                  			  Unused Relocatable        proc_GEN_0000:0053H
_end_processing                                                                 			  Unused Relocatable        proc_GEN_0000:003AH
_fir_basic                                                                      			         Relocatable         proc_GEN_0000:0045H
_hpfCoefs                                                                       					 External   
_hpfHistoryBuffer                                                               					 External   
_inputGain                                                                      					 External   
_limiterThreshold                                                               					 External   
_lpfCoefs                                                                       					 External   
_lpfHistoryBuffer                                                               					 External   
_meter_h_                                                                       			  Unused Relocatable        __INIT:0000H
_modeFlag                                                                       					 External   
_processing                                                                     			  Public Relocatable       proc_GEN_0000:0000H
_response_h_                                                                    			  Unused Relocatable        __INIT:0000H
_saturation                                                                     					 External   
example_module_MCV                                                              					 External   
isDefined                                                                       			  Unused Number				      1 (1H)

	       SEGMENTS:

Size			  Name										 Class
0000H	 __INIT                                  			 CODE                                    
0056H	 proc_GEN_0000                           			 CODE_OVLY                               
